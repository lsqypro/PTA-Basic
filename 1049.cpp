//
// Created by lsqy on 2020/8/9.
//

/* 1049 数列的片段和 (20分)
 * 耗时：53:26.68
 *
 * 1. 遍历每一个元素，计算每个元素出现在序列中的个数，个数*元素值即为该元素在总和中的占比
 *      如：在(0.1) (0.1, 0.2) (0.1, 0.2, 0.3) (0.1, 0.2, 0.3, 0.4) (0.2) (0.2, 0.3) (0.2, 0.3, 0.4) (0.3) (0.3, 0.4) (0.4) 这 10 个片段
 *      ans = 0.1*4 + 0.2*6 + 0.3*6 * 0.4*4 = 5.00
 * 2. 一个元素组成的连续序列数为：该元素之前的取值个数（0,1,2,...,i） * 该元素之后的取值个数(0,1,2,3,...,n-i-1)
 * 3. 对于测试点2：
 *      浮点数精度限制，对于部分小数：十进制->二进制时会丢失精度（二进制小数和十进制小数并不是一一对应关系）
 *      在累加过程中可能导致某些精度丢失
 *      解决方案:
 *          1. 使用long long 放大1000倍能通过
 *          2. 自定义Double数据类型
 */

#include <iostream>

using namespace std;

#define MULT 1000.0

int main(void) {
    int n;
    double value;
    long long ans = 0;
    cin >> n;
    for (int i = 0; i < n; ++i) {
        cin >> value;
        ans += (long long)(MULT * value) * (i+1) * (n-i);
    }
    printf("%0.2f\n", ans/MULT);

    return 0;
}